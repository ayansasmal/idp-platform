#!/bin/bash

# IDP Configuration Manager
# Consolidated script for managing IDP platform configuration
# Combines config-parser.sh and idp-setup-wizard.sh functionality

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"
CONFIG_DIR="$ROOT_DIR/.idp-config"
CONFIG_FILE="$CONFIG_DIR/idp-config.yaml"

# Logging functions
log() {
    echo -e "${GREEN}[$(date +'%H:%M:%S')] $1${NC}"
}

warn() {
    echo -e "${YELLOW}[$(date +'%H:%M:%S')] WARNING: $1${NC}"
}

error() {
    echo -e "${RED}[$(date +'%H:%M:%S')] ERROR: $1${NC}"
}

info() {
    echo -e "${BLUE}[$(date +'%H:%M:%S')] INFO: $1${NC}"
}

# Usage information
usage() {
    cat << EOF
IDP Configuration Manager

USAGE:
    $0 [COMMAND] [OPTIONS]

COMMANDS:
    wizard                  Interactive configuration wizard
    show                   Display current configuration
    validate               Validate configuration file
    parse KEY              Parse specific configuration value
    export                 Export configuration as environment variables
    reset                  Reset configuration to defaults
    backup                 Backup current configuration
    restore BACKUP         Restore from backup

OPTIONS:
    --config-file FILE     Custom configuration file path
    --format FORMAT        Output format (yaml|json|env) for show command
    --help                 Show this help message

EXAMPLES:
    $0 wizard                    # Run interactive configuration wizard
    $0 show                     # Display current configuration
    $0 parse platform.name      # Get platform name value
    $0 export                   # Export as environment variables
    $0 validate                 # Validate configuration

EOF
}

# Parse YAML value
parse_yaml_value() {
    local key="$1"
    local file="${2:-$CONFIG_FILE}"
    
    if [ -f "$file" ]; then
        # Handle nested keys (e.g., platform.name)
        if [[ "$key" == *.* ]]; then
            local parent_key="${key%.*}"
            local child_key="${key##*.}"
            
            # Simple nested parsing - look for parent section, then child key
            awk "/^[[:space:]]*${parent_key}:/,/^[[:space:]]*[^[:space:]]/ {
                if (\$0 ~ /^[[:space:]]*${child_key}:[[:space:]]*/) {
                    gsub(/^[[:space:]]*${child_key}:[[:space:]]*/, \"\")
                    print
                    exit
                }
            }" "$file"
        else
            # Simple key parsing
            grep "^[[:space:]]*${key}:" "$file" 2>/dev/null | \
                sed 's/.*:[[:space:]]*//' | \
                sed 's/^[[:space:]]*//' | \
                sed 's/[[:space:]]*$//' | \
                head -n1
        fi
    fi
}

# Check if key exists and has value
yaml_key_exists() {
    local key="$1"
    local file="${2:-$CONFIG_FILE}"
    
    if [ -f "$file" ]; then
        local value
        value=$(parse_yaml_value "$key" "$file")
        [ -n "$value" ] && [ "$value" != "false" ] && [ "$value" != "null" ]
    else
        return 1
    fi
}

# Create default configuration
create_default_config() {
    log "Creating default configuration..."
    
    mkdir -p "$CONFIG_DIR"
    
    cat > "$CONFIG_FILE" << EOF
# IDP Platform Configuration
# Generated by configuration-manager.sh

platform:
  name: "IDP Platform"
  namespace: "idp-system"
  domain: "idp.local"
  mode: "development"  # development, staging, production
  
deployment:
  cluster_type: "local"  # local, kind, minikube, eks, gke, aks
  enable_monitoring: true
  enable_tracing: true
  enable_logging: true
  
authentication:
  provider: "cognito"  # cognito, oauth2, ldap
  enable_rbac: true
  session_timeout: "8h"
  
storage:
  type: "local"  # local, s3, gcs, azure
  backup_enabled: false
  retention_days: 30
  
security:
  enable_network_policies: true
  enable_pod_security: true
  enable_audit_logging: true
  enable_encryption: true
  
external_services:
  localstack:
    enabled: true
    endpoint: "http://localhost:4566"
  prometheus:
    enabled: true
    retention: "15d"
  grafana:
    enabled: true
    admin_password: "admin"
  
features:
  feature_flags: true
  cost_insights: false
  multi_cluster: false
  disaster_recovery: false

# Generated on: $(date)
# Version: 1.0
EOF

    log "Default configuration created at: $CONFIG_FILE"
}

# Interactive configuration wizard
run_wizard() {
    log "🧙‍♂️ IDP Platform Configuration Wizard"
    echo ""
    
    # Create config directory if it doesn't exist
    mkdir -p "$CONFIG_DIR"
    
    # Platform configuration
    info "Platform Configuration"
    echo -n "Platform name [IDP Platform]: "
    read -r platform_name
    platform_name=${platform_name:-"IDP Platform"}
    
    echo -n "Platform namespace [idp-system]: "
    read -r platform_namespace
    platform_namespace=${platform_namespace:-"idp-system"}
    
    echo -n "Platform domain [idp.local]: "
    read -r platform_domain
    platform_domain=${platform_domain:-"idp.local"}
    
    echo -n "Deployment mode (development/staging/production) [development]: "
    read -r platform_mode
    platform_mode=${platform_mode:-"development"}
    
    echo ""
    info "Deployment Configuration"
    echo -n "Cluster type (local/kind/minikube/eks/gke/aks) [local]: "
    read -r cluster_type
    cluster_type=${cluster_type:-"local"}
    
    echo -n "Enable monitoring? (y/N) [y]: "
    read -r enable_monitoring
    enable_monitoring=${enable_monitoring:-"y"}
    enable_monitoring_bool=$([ "$enable_monitoring" = "y" ] && echo "true" || echo "false")
    
    echo -n "Enable distributed tracing? (y/N) [y]: "
    read -r enable_tracing
    enable_tracing=${enable_tracing:-"y"}
    enable_tracing_bool=$([ "$enable_tracing" = "y" ] && echo "true" || echo "false")
    
    echo ""
    info "Authentication Configuration"
    echo -n "Authentication provider (cognito/oauth2/ldap) [cognito]: "
    read -r auth_provider
    auth_provider=${auth_provider:-"cognito"}
    
    echo -n "Enable RBAC? (y/N) [y]: "
    read -r enable_rbac
    enable_rbac=${enable_rbac:-"y"}
    enable_rbac_bool=$([ "$enable_rbac" = "y" ] && echo "true" || echo "false")
    
    echo ""
    info "Storage Configuration"
    echo -n "Storage type (local/s3/gcs/azure) [local]: "
    read -r storage_type
    storage_type=${storage_type:-"local"}
    
    echo -n "Enable backups? (y/N) [n]: "
    read -r enable_backup
    enable_backup=${enable_backup:-"n"}
    enable_backup_bool=$([ "$enable_backup" = "y" ] && echo "true" || echo "false")
    
    echo ""
    info "Security Configuration"
    echo -n "Enable network policies? (y/N) [y]: "
    read -r enable_network_policies
    enable_network_policies=${enable_network_policies:-"y"}
    enable_network_policies_bool=$([ "$enable_network_policies" = "y" ] && echo "true" || echo "false")
    
    echo -n "Enable audit logging? (y/N) [y]: "
    read -r enable_audit_logging
    enable_audit_logging=${enable_audit_logging:-"y"}
    enable_audit_logging_bool=$([ "$enable_audit_logging" = "y" ] && echo "true" || echo "false")
    
    # Create configuration file
    log "Creating configuration file..."
    
    cat > "$CONFIG_FILE" << EOF
# IDP Platform Configuration
# Generated by configuration wizard

platform:
  name: "$platform_name"
  namespace: "$platform_namespace"
  domain: "$platform_domain"
  mode: "$platform_mode"
  
deployment:
  cluster_type: "$cluster_type"
  enable_monitoring: $enable_monitoring_bool
  enable_tracing: $enable_tracing_bool
  enable_logging: true
  
authentication:
  provider: "$auth_provider"
  enable_rbac: $enable_rbac_bool
  session_timeout: "8h"
  
storage:
  type: "$storage_type"
  backup_enabled: $enable_backup_bool
  retention_days: 30
  
security:
  enable_network_policies: $enable_network_policies_bool
  enable_pod_security: true
  enable_audit_logging: $enable_audit_logging_bool
  enable_encryption: true
  
external_services:
  localstack:
    enabled: true
    endpoint: "http://localhost:4566"
  prometheus:
    enabled: $enable_monitoring_bool
    retention: "15d"
  grafana:
    enabled: $enable_monitoring_bool
    admin_password: "admin"
  
features:
  feature_flags: true
  cost_insights: false
  multi_cluster: false
  disaster_recovery: false

# Generated on: $(date)
# Generated by: configuration wizard
EOF

    log "✅ Configuration saved to: $CONFIG_FILE"
    echo ""
    info "Configuration Summary:"
    show_config
}

# Show current configuration
show_config() {
    local format="${1:-yaml}"
    
    if [ ! -f "$CONFIG_FILE" ]; then
        warn "Configuration file not found. Run 'wizard' or 'reset' to create one."
        return 1
    fi
    
    case "$format" in
        yaml)
            info "Current IDP Configuration:"
            echo ""
            cat "$CONFIG_FILE" | grep -v '^#' | grep -v '^[[:space:]]*$'
            ;;
        json)
            info "Configuration in JSON format:"
            if command -v yq &> /dev/null; then
                yq eval -o=json "$CONFIG_FILE"
            else
                warn "yq not available, showing YAML format instead"
                show_config yaml
            fi
            ;;
        env)
            info "Configuration as environment variables:"
            export_config
            ;;
        *)
            error "Unknown format: $format"
            return 1
            ;;
    esac
}

# Export configuration as environment variables
export_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        error "Configuration file not found"
        return 1
    fi
    
    # Parse and export key configuration values
    local platform_name platform_namespace platform_domain platform_mode
    local cluster_type auth_provider storage_type
    
    platform_name=$(parse_yaml_value "platform.name")
    platform_namespace=$(parse_yaml_value "platform.namespace")
    platform_domain=$(parse_yaml_value "platform.domain")
    platform_mode=$(parse_yaml_value "platform.mode")
    cluster_type=$(parse_yaml_value "deployment.cluster_type")
    auth_provider=$(parse_yaml_value "authentication.provider")
    storage_type=$(parse_yaml_value "storage.type")
    
    echo "export IDP_PLATFORM_NAME=\"$platform_name\""
    echo "export IDP_PLATFORM_NAMESPACE=\"$platform_namespace\""
    echo "export IDP_PLATFORM_DOMAIN=\"$platform_domain\""
    echo "export IDP_PLATFORM_MODE=\"$platform_mode\""
    echo "export IDP_CLUSTER_TYPE=\"$cluster_type\""
    echo "export IDP_AUTH_PROVIDER=\"$auth_provider\""
    echo "export IDP_STORAGE_TYPE=\"$storage_type\""
    
    # Export boolean flags
    if yaml_key_exists "deployment.enable_monitoring"; then
        echo "export IDP_ENABLE_MONITORING=true"
    else
        echo "export IDP_ENABLE_MONITORING=false"
    fi
    
    if yaml_key_exists "authentication.enable_rbac"; then
        echo "export IDP_ENABLE_RBAC=true"
    else
        echo "export IDP_ENABLE_RBAC=false"
    fi
    
    if yaml_key_exists "security.enable_network_policies"; then
        echo "export IDP_ENABLE_NETWORK_POLICIES=true"
    else
        echo "export IDP_ENABLE_NETWORK_POLICIES=false"
    fi
}

# Validate configuration file
validate_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        error "Configuration file not found: $CONFIG_FILE"
        return 1
    fi
    
    log "Validating configuration file..."
    
    local errors=0
    
    # Check required sections
    local required_sections=("platform" "deployment" "authentication" "storage" "security")
    for section in "${required_sections[@]}"; do
        if ! grep -q "^${section}:" "$CONFIG_FILE"; then
            error "Missing required section: $section"
            ((errors++))
        fi
    done
    
    # Check required platform fields
    local required_platform_fields=("name" "namespace" "domain" "mode")
    for field in "${required_platform_fields[@]}"; do
        if ! yaml_key_exists "platform.$field"; then
            error "Missing required platform field: $field"
            ((errors++))
        fi
    done
    
    # Validate platform mode
    local platform_mode
    platform_mode=$(parse_yaml_value "platform.mode")
    if [[ "$platform_mode" != "development" && "$platform_mode" != "staging" && "$platform_mode" != "production" ]]; then
        error "Invalid platform mode: $platform_mode (must be development, staging, or production)"
        ((errors++))
    fi
    
    # Validate cluster type
    local cluster_type
    cluster_type=$(parse_yaml_value "deployment.cluster_type")
    local valid_cluster_types=("local" "kind" "minikube" "eks" "gke" "aks")
    local cluster_type_valid=false
    for valid_type in "${valid_cluster_types[@]}"; do
        if [[ "$cluster_type" == "$valid_type" ]]; then
            cluster_type_valid=true
            break
        fi
    done
    if [[ "$cluster_type_valid" == false ]]; then
        error "Invalid cluster type: $cluster_type"
        ((errors++))
    fi
    
    # Validate authentication provider
    local auth_provider
    auth_provider=$(parse_yaml_value "authentication.provider")
    local valid_auth_providers=("cognito" "oauth2" "ldap")
    local auth_provider_valid=false
    for valid_provider in "${valid_auth_providers[@]}"; do
        if [[ "$auth_provider" == "$valid_provider" ]]; then
            auth_provider_valid=true
            break
        fi
    done
    if [[ "$auth_provider_valid" == false ]]; then
        error "Invalid authentication provider: $auth_provider"
        ((errors++))
    fi
    
    if [ $errors -eq 0 ]; then
        log "✅ Configuration validation passed"
        return 0
    else
        error "❌ Configuration validation failed with $errors error(s)"
        return 1
    fi
}

# Backup current configuration
backup_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        error "No configuration file to backup"
        return 1
    fi
    
    local backup_file="$CONFIG_DIR/idp-config-backup-$(date +%Y%m%d-%H%M%S).yaml"
    cp "$CONFIG_FILE" "$backup_file"
    
    log "Configuration backed up to: $backup_file"
}

# Restore configuration from backup
restore_config() {
    local backup_file="$1"
    
    if [ ! -f "$backup_file" ]; then
        error "Backup file not found: $backup_file"
        return 1
    fi
    
    warn "This will overwrite the current configuration. Continue? (y/N)"
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        cp "$backup_file" "$CONFIG_FILE"
        log "Configuration restored from: $backup_file"
    else
        info "Restore cancelled"
    fi
}

# Reset configuration to defaults
reset_config() {
    warn "This will reset the configuration to defaults. Continue? (y/N)"
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        backup_config 2>/dev/null || true
        create_default_config
    else
        info "Reset cancelled"
    fi
}

# Main command handler
main() {
    case "${1:-}" in
        wizard)
            run_wizard
            ;;
        show)
            local format="${2:-yaml}"
            show_config "$format"
            ;;
        validate)
            validate_config
            ;;
        parse)
            if [ -z "${2:-}" ]; then
                error "Please specify a key to parse"
                exit 1
            fi
            local value
            value=$(parse_yaml_value "$2")
            if [ -n "$value" ]; then
                echo "$value"
            else
                error "Key not found or empty: $2"
                exit 1
            fi
            ;;
        export)
            export_config
            ;;
        reset)
            reset_config
            ;;
        backup)
            backup_config
            ;;
        restore)
            if [ -z "${2:-}" ]; then
                error "Please specify backup file to restore"
                exit 1
            fi
            restore_config "$2"
            ;;
        --help|help)
            usage
            ;;
        *)
            if [ -n "${1:-}" ]; then
                error "Unknown command: $1"
            else
                info "No command specified"
            fi
            echo ""
            usage
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"